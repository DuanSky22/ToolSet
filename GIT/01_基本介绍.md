---
typora-copy-images-to: pic
---

[TOC]

# Git 基本介绍

> 本章节重点讲解Git的原理和Git的基本概念。通过本章的学习，可以清楚了解Git是如何工作的。本文假设你已经了解Git的基本使用规则，如果没有Git基础，请参考廖雪峰的Git教程。

## 参考资料

[一步一步的观察Git执行过程](http://blog.xiayf.cn/2013/09/28/learning-git-internals-by-example/)

[大而全的Git学习资料](https://github.com/xirong/my-git)

[廖雪峰的Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

## 基本概念 

### 版本库（Repository）、暂存区（Stage）、工作空间（Working Directory）

作为分布式版本管理系统Git，有三个最为核心的概念：版本库、暂存区和工作空间。

+ **工作空间（Working Directory）**：工作空间是用来存放需要管理的内容，可能是用户编写的代码、文档等等。
+ **版本库（Repository）**：和工作空间的同级目录中有一个`.git`文件夹，这个文件夹就是git的版本库。版本库里存放很多管理信息，如暂存区（index）、日志（logs）、所有的引用（refs）等，是管理控制系统的核心。
+ **暂存区（Stage）**：在版本库下的名为`index`的文件。暂存区用来存储工作空间内的文件的修改。

![](pic/workset.etc.png)

这三个区是如何进行交互的呢？

1. 通过`git add`命令将工作区内的修改（增删改）提交到暂存区；
2. 通过`git commit`命令将暂存区的内容提交到当前分支；
3. 通过`git push`命令将仓库的当前分支提交到远程仓库中。

下面我们将详细讲解这三个概念。

#### 工作空间（Working Directory）

​	严格来讲，工作空间是和分支相关联的。当前的工作空间是指在某个特定的分支下的文件集合，工作空间以文件的形式方便用户编辑和阅读（区别于objects中的二进制文件）。因此当用户切换分支时，将当前的工作空间文件将会发生改变：所有要切换的分支的文件将会被展现，而被切换的分支的文件将会被删除，因此在用户切换分支时，一定要先将当前分支的修改commit到版本库中，以免发生文件丢失。

​	如果将当前工作空间的修改`git add`到了暂存区，然后切换分支会怎么样？Git将会有如下错误：

![](pic/switch_workdir.jpg)

​	因此，我们可以说工作空间是临时的，不可靠的，所有的数据在本地仓库中永久的保存。而工作空间只是用来编辑和提交改变而已。

#### 版本库（Repository/ .git）

版本库即为.git文件夹存储的内容，我们将通过分析.git文件夹的内容来分析版本库。.git文件夹如下所示：

![](pic/.git.jpg)

+ **HEAD**：用来指向当前工作空间的分支，其实HEAD就是一个引用（或者叫指针），这个引用指向了当前工作空间的分支。例如在本实例中，HEAD的内容如下：`ref: refs/heads/master`，它指向了refs文件夹下的heads文件夹下的master分支。更多详细的关于HEAD的定位commit过程，请参考本章节中的[Q1: Git HEAD是如何定位的](#Q1: Git HEAD是如何定位的？)。

+ **refs**：存放了git的所有的引用，包括本地分支（heads/）、远程仓库分支（remotes/）以及标签（tags/）等，这些分支或标签本质上也是一个引用，他们指向了该分支的最近一次的commit。它的组织结构如下所示：

  ![](pic/refs.jpg)

  + **heads**： 存放本地各个分支的最后一次的commit 引用（该引用采用SHA-1数值标识）。例如该工作空间有两个分支：master和test，分别对应两个文件。其中master文件内容为`bb840425661b0befe1b00305d87d4b6244ff5e62`，它标识了当前master分支的最后一次commit的SHA-1值，用户可以根据这个值找到这次commit的结果，test同理。
  + **remotes**：存放远程各个分支的最后一次commit引用（该引用采用SHA-1数值标识）。例如在远程仓库origin中有两个分支：master和test，分别对应两个文件。其中master文件内容为`bb840425661b0befe1b00305d87d4b6244ff5e62`，它标识了当前master分支的最后一次commit的SHA-1值，用户可以根据这个值找到这次commit的结果，test同理。我们发现这个值和heads/master所存储的值相同，说明本地仓库和远程仓库的最新内容是一致的。（严格来讲，这里所说的一致是指截止到上次提交时，这两个仓库的内容是一样的，还有可能存在本地已经修改而且提交到暂存区，但是还没有提交到本地仓库，这时暂存区的内容和远程仓库的内容就不是一致的了）。
  + **tags**：存放本地各个tag的最后一次的commit 引用（该引用采用SHA-1数值标识）。例如在该空间中有两个tag：v0.9和v1.0，我们打开v1.0，其存储内容为`bb840425661b0befe1b00305d87d4b6244ff5e62`，这与前面master内容一致，说明是在该版本上打的tag。
  + **config**：这是Git主要的配置文件，它配置了远程仓库地址等信息。Git的配置文件加载顺序为：`.git/config` -> `~/.gitconfig`->`/etc/gitconfig`。

  ```
  [core]
  	repositoryformatversion = 0
  	filemode = false
  	bare = false
  	logallrefupdates = true
  	symlinks = false
  	ignorecase = true
  	hideDotFiles = dotGitOnly
  [remote "origin"]
  	url = git@github.com:DuanSky22/ToolSet.git
  	fetch = +refs/heads/*:refs/remotes/origin/*
  [branch "master"]
  	remote = origin
  	merge = refs/heads/master

  ```

  ​

+ **logs**：用户所有提交的日志记录都在logs文件夹中，用户可以通过`git log`命令来查看之前提交的日志记录。该文件夹的组织形式如下：

  ![](pic/logs.jpg)

  + **HEAD**：所有提交的日志记录都在这里，按照如下方式来组织：

  ```
  0000000000000000000000000000000000000000 3456c135ef07f3418d8577e0bfd137349b4e6e60 DuanSky <duansky22@163.com> 1496641940 +0800	commit (initial): first commit
  3456c135ef07f3418d8577e0bfd137349b4e6e60 bb840425661b0befe1b00305d87d4b6244ff5e62 DuanSky <duansky22@163.com> 1496913492 +0800	commit: 完成Maven手册的编写
  bb840425661b0befe1b00305d87d4b6244ff5e62 bb840425661b0befe1b00305d87d4b6244ff5e62 DuanSky <duansky22@163.com> 1497260029 +0800	checkout: moving from master to test
  ```

  ​	文件中的每一行代表一次提交的日志记录，每一次的提交日志由（上次提交的SHA-1值，本次提交的SHA-1值，本次提交作者，本次提交账号，本次提交时间、时区，提交信息）这七部分组成，在本实例中总共有三次提交记录。

  + **refs**：存储着本地（heads文件夹）和远程（remotes文件夹）的提交日志记录。例如在heads文件夹中有master和test两个文件，master文件存储的是master分支的所有提交日志记录，其内容的组织形式和HEAD文件的组织形式相同，内容如下所示：

  ```
  0000000000000000000000000000000000000000 3456c135ef07f3418d8577e0bfd137349b4e6e60 DuanSky <duansky22@163.com> 1496641940 +0800	commit (initial): first commit
  3456c135ef07f3418d8577e0bfd137349b4e6e60 bb840425661b0befe1b00305d87d4b6244ff5e62 DuanSky <duansky22@163.com> 1496913492 +0800	commit: 完成Maven手册的编写
  ```

+ **index**：即所谓的暂存区，是一个二进制文件，用户通过`git add`命令将工作空间内的改动添加到暂存区中。更多关于暂存区的介绍，请参考[暂存区（Stage/ .git/index）](#暂存区（Stage/ .git/index）)

+ **objects**：存放所有Git对象数据的地方，包括用户提交的文件内容，commit 信息、树（tree）以及标签（tag）对象等，这可以看做是Git内嵌的小型数据库，它以二进制的形式记录了所有Git对象，每个对象都有唯一的由40个字符的SHA-1组成的ID号，这个ID号中，前面两个字符是目录名，后面38个字符是文件名。例如某个SHA-1值为`2bd03a1faa73c9c4891a6556bcb0f1358364707c`的对象存储在`.git/objects/2b文件夹下的`d03a1faa73c9c4891a6556bcb0f1358364707c`文件中。文件夹组织结构如下图所示：

![](pic/objects.jpg)

+ **hooks**：该目录包含了git命令所调用的脚本，例如当你执行`git commit`时，git首先会执行`git post-commit`脚本，如果有执行权限的话才会继续执行。一般不会对这里进行修改，可以忽略。

完整的.git文件夹内容如下所示：

![](pic/.git.png)

#### 暂存区（Stage/ .git/index）

​	Git有两个地方来存储数据：工作空间和本地仓库。工作空间是从用户的视角出发，以方便用户编辑阅读的方式来存储文件数据；当用户将数据commit到本地仓库后，这些数据又会以二进制的形式被永久的存储在特定的数据库中（即存储在.git/objects目录下）；那么用户如何决定哪些工作空间的改动commit到本地仓库呢？或许你希望能够一个第三方文件，它能够记录你将要选取哪些工作空间的改动文件存储到本地仓库中，这个文件就是index。index文件也被称为缓存区（cache）（或者本文所说的暂存区），它是在工作空间和本地仓库的中间地带，用户可以先将工作空间的某些改动添加index中，然后再将index中包含的所有改动一次性提交到本地仓库中。

​	通过前面的讲述我们知道通过`git add`命令能够将工作空间修改的内容添加到暂存区，然后再通过`git commit`命令将暂存区中的内容全部提交给仓库，我们在使用`git status`命令时，常常发现文件会有如下几种类型：

1. 未被跟踪的文件（Untracked files）--> 用户新建的之前从来没有添加到暂存区的文件
2. 被修改但未被暂存的文件（Changes not staged for commit）--> 用户之前添加过暂存区的但是又在工作空间修改了没有提交到暂存区的文件
3. 已暂存可以被提交的文件（changes to be committed） --> 已经添加到暂存区中可以被提交的文件
4. 自上次提交以来未修改的文件（clean）--> 没有文件被改动而且暂存区也为空

​        需要注意的是第一种文件一般是用户新建的文件，这些文件之前也没有添加到暂存区，所以是无法追踪的；而第二种文件是之前已经存在的用户修改的但没有添加到暂存区的文件，是可以追踪的。如果结合版本库、暂存区和工作空间来看，文件的状态转换如下：

![](pic/status.png)

​	用户在工作空间中新增加文件（例如新增加 a.txt）会被定义为`Untracked files`，用户修改原来已经添加到仓库的文件（例如README）会被定义为`changes not staged for commit`，这两种文件都是用户修改的但未被添加到暂存区中的文件；通过使用`git add`命令之后，这些文件会被添加到暂存区中，此时文件的状态为`changes to be committed`，表示这些文件已经准备被提交到仓库中了；通过使用`git commit`命令，这些文件会被添加到仓库中，完成了整个过程，此时这些文件的状态为`clean`，很"干净"，所有的修改都已经提到到仓库了。

这些文件类型本质上是对应了4种状态：

+ untracked：还没添加到仓库中。

+ modified：已经在工作空间中修改但还没添加到暂存区中。

+ staged：已经添加到暂存区但还没提交到仓库中。

+ unmodified：自上次提交以来，文件未曾修改过。

  这四种状态的转换如下： 

![img](pic/status1.jpg)

​	上述讲述了一个文件从工作区到暂存区再到最后的仓库中的整个流程，是一个正常的文件状态转换过程。那么考虑这样一种情况，如果我修改了某个已经提交到暂存区的文件，此时整个文件的状态是什么呢？

（1）创建一个文件”b.txt"，此时使用`git status`会显示这个文件是`Untracked files`，如下图所示：

![](pic/status-1.jpg)

（2）使用`git add`命令将这个文件添加到暂存区中，此时这个文件的状态为`changes to be committed`，如下图所示：

![1497271946518](pic/1497271946518.png)

（3）使用`touch "b" >> b.txt`命令向b.txt文件中新增加内容，然后使用`git status`命令，此时文件的状态如下所示，我们发现这个文件有两个状态：`changes to be committed`和`changes not staged for commit`。第一个状态是我们在第二步中`git add`命令添加到暂存区中的文件b.txt，第二个状态是我们又修改了但还没有被添加到暂存区中的文件b.txt，实际上这两个状态都是一个文件；为什么会有两个状态呢？这是因为每次执行`git add`添加文件到暂存区时，它都会把文件内容进行SHA1哈希运算，在索引文件中新加一项，再把文件内容存放到本地的objects里。如果在上次执行 `git add`之后再对文件的内容进行了修改，那么在执行`git status`命令时，Git会对文件内容进行SHA1哈希运算就会发现文件又被修改了，这时“b.txt“就同时呈现了两个状态：被修改但未被暂存的文件（changed but not updated），已暂存可以被提交的文件（changes to be committed）。如果我们这时提交的话，就是只会提交第一次`git add`所以暂存的文件内容。

![1497283886084](pic/1497283886084.png)

​	我们知道了暂存区里面存放了与当前暂存内容相关的信息，包括暂存的文件名、文件内容的SHA1哈希串值和文件访问权限，整个索引文件的内容以暂存的文件名进行排序保存的。关于暂存区的常用命令有如下几个：

```
$ git add filename 将文件添加到暂存区
$ git ls-files --stage 查看暂存区中的所有文件
$ git rm --cached filename 删除暂存区中的filename文件
```



### 实体（Objects）、引用（References）、索引（index）

​	如果说版本库、暂存区和工作空间是从宏观的角度描述git的工作过程，那么实体、引用和索引是从微观的角度描述git的工作过程。下面我们将重点阐述这三者之间的关系以及他们是如何进行交互的。他们三者的关系如下图所示（这个图非常经典，基本上阐述了整个git的工作过程）：

![](pic/objects.etc.png)

+ **实体（Object）**：提交到一个Git代码仓库中的所有文件，包括每个提交的说明信息（the commit info）都在目录 `.git/objects/`中存储为**实体**。一个实体用一个长度为40个字符长度的SHA-1哈希值来标识。按照实体类型的不同，一般有如下四类：

  + **blob**：存储文件的内容，用户每次通过`git add`命令将工作空间内的文件修改提交到暂存区时，工作空间内的文件修改内容都会写到该blob中。例如README文件中的内容就是以blob的形式存储。
  + **tree**：存储目录结构和文件名。例如lib/这样的目录就是以tree的形式存储。
  + **commit**：用户每次commit时都会生成一个commit节点，这个节点是由blob和tree组成的，反应了此次commit的全部内容。在上述的`logs`文件夹分析中我们知道logs中的HEAD文件详细描述了commit的提交图谱。
  + **tag**：存储带注释的标签（tag），每个tag实际上会指向某个特定的commit。

  >|>补充说明<| 
  >
  >Git与其他版本控制系统的区别在于：Git只关心文件是否变化，而不关心文件内容的变化。大多数版本控制系统都会忠实地记录版本间的文件差异（diff），但Git不关心这些具体差异（哪一行有什么变动），Git只关心哪些文件修改了哪些没有修改，修改了的文件直接复制形成新的blob（这就是所谓的快照snapshot）。当你需要切换到或拉出一个分支时，Git就直接加载当时的文件快照即可，这就是Git快的原因。这也是用空间换取时间的经典案例。

+ **引用（Reference）**：指向某个commit或branch的引用。因此就有这两种引用：（1）直接指向commit实体的引用，这些引用在`.git/refs/heads`、`.git/refs/remotes`、`.git/refs/tags`下，他们直接指向了某个具体的commit或tag；（2）符号引用，它们不直接指向实体，而是指向另外一个引用，如`.git/HEAD`就是一个符号引用，它指向当前工作空间的某个分支（本质上分支只是一个引用），而不是某个具体的实体。

+ **索引（Index）**：从宏观概念上来讲其实就是暂存区（Stage），这里叫做索引是一个意思，它是以二进制的形式来存储使用`git add`命令添加到暂存区中的文件信息。使用`git commit `命令只会提交添加到暂存区中的文件。

## 核心问题

通过上面对Git概念的讲解，下面我们以问题的方式来加深对git原理的探索。

### Q1: Git HEAD是如何定位的？

​	Git的版本控制非常方便，通过引入头指针，每次的修改都对应了一个指针，这样只需要移动指针就能够快速的在版本之间进行切换（这种切换既包括不同分支之间的切换，也包括同一分支的不同版本进行切换）。那么Git是如何定位当前工作空间的版本呢？我们用如下的图来阐述定位过程（图中的圈表示一次commit）：

![](pic/HEAD.png)

​	head定位分两步进行，第一步是定位当前的工作空间是在哪个分支上，例如本实例中通过`.git/HEAD`文件内容`ref:refs/heads/master`定位当前工作空间是指向本地分支master的；第二步是定位当前分支的哪个版本上，本实例中通过`.git/heads/master`文件内容的SHA-1码`bb840425661b0befe1b00305d87d4b6244ff5e62`定位在该分支的哪个commit上。

### Q2: 索引、引用和实体是如何交互的？

​	详细的示例请参考[通过示例学习Git内部构造（译）](http://blog.xiayf.cn/2013/09/28/learning-git-internals-by-example/)。

### Q3：常用的Git命令到底做了些什么？

​	详细的解释请参考[02_常用命令.md](02_常用命令.md)。